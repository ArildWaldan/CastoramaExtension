// ==UserScript==
// @name         Kingfisher Tableau de Bord (v3.0 - Analyse AvancÃ©e des Surplus)
// @namespace    http://tampermonkey.net/
// @version      3.0
// @description  Utilise la capacitÃ© maximale de l'API pour une analyse prÃ©cise des surplus de stock.
// @author       You
// @match        https://dc.kfplc.com/*
// @connect      dc.dps.kd.kfplc.com
// @connect      eegserver1502.frca.kfplc.com
// @grant        GM_xmlhttpRequest
// @grant        GM_addStyle
// @grant        GM.setValue
// @grant        GM.getValue
// ==/UserScript==

(function() {
    'use strict';

    // --- CONFIGURATION ---
    const API_BASE_URL = 'https://dc.dps.kd.kfplc.com';
    const FLASH_SERVER_URL = 'http://eegserver1502.frca.kfplc.com:3333';
    const DEFAULT_MAX_CAPACITY = 30; // Fallback if API doesn't provide a 'maximum'
    const CACHE_DURATION_MS = 24 * 60 * 60 * 1000; // 24 hours
    const FLASH_COOLDOWN_MS = 30 * 60 * 1000; // 30 minutes

    const BAYS_TO_CHECK = [
        { aisle: '060', bay: '03' },
        { aisle: '060', bay: '09' },
        { aisle: '060', bay: '012' },
        { aisle: '060', bay: '015' },
        { aisle: '060', bay: '019' },

    ];

    // --- TRADUCTION (i18n) ---
    const i18n = { dashboardTitle: "Tableau de Bord Livraisons Tasseaux", statusComplete: "Analyse terminÃ©e pour les allÃ©es: {bays}", loadingFromCache: "Chargement des donnÃ©es depuis le cache...", forcingReload: "ForÃ§age du rechargement des donnÃ©es...", step1: "Ã‰tape 1/3: RÃ©cupÃ©ration des infos de plannogramme...", step2: "Ã‰tape 2/3: RÃ©cupÃ©ration des EANs pour {count} plannos(s)...", step3: "Ã‰tape 3/3: RÃ©cupÃ©ration des dÃ©tails produits... ({checked}/{total})", finalizing: "Finalisation: Analyse et construction du tableau de bord...", errorLayout: "Erreur: Aucune information de layout trouvÃ©e pour les baies spÃ©cifiÃ©es.", errorEan: "Erreur: Layouts trouvÃ©s, mais aucun produit (EAN) n'a pu Ãªtre rÃ©cupÃ©rÃ©.", errorCritical: "Une erreur critique est survenue: {message}", errorCheckConsole: "Veuillez ouvrir la console du navigateur (F12) pour les dÃ©tails.", productsAnalyzed: "Produits AnalysÃ©s", locationAnomalies: "Anomalies d'Emplacement", overflowRisks: "Risques de Surplus", upcomingPOs: "Commandes Ã  Venir", anomaliesTitle: "Anomalies d'Emplacement", overflowAnalysisTitle: "Analyse des Surplus", poBreakdownTitle: "DÃ©tail des Commandes", highStockTitle: "Top Stocks avec Livraisons", productNameHeader: "Produit", locationHeader: "Emplacements 'Vides'", stockMaxHeader: "Stock / Max", potentialSurplusHeader: "Surplus PrÃ©vu", poNumberHeader: "NÂ° de Commande", riskPercentHeader: "Risque %", detailsHeader: "DÃ©tails", deliveryQtyHeader: "QtÃ© LivrÃ©e", noAnomalies: "Aucune anomalie d'emplacement trouvÃ©e.", noOverflowRisks: "Aucun surplus de stock prÃ©vu.", noPOs: "Aucune commande en cours trouvÃ©e.", noHighStock: "Aucun produit correspondant trouvÃ©.", riskDetails: "{overflow} sur {total} articles Ã  risque", noPoDelivery: "(Sans Commande) {date}", };

    // --- LOGGING & API FUNCTIONS ---
    const log = (level, message, data = '') => { const prefix = '[KFS Dashboard]'; const styles = { error: 'color: #d32f2f; font-weight: bold;', warn: 'color: #f57c00; font-weight: bold;', info: 'color: #0288d1;' }; console[level](`%c${prefix} ${message}`, styles[level] || styles.info, data); };
    const getApiHeaders = () => ({ "Accept": "application/json", "Content-Type": "application/json", "Host": "dc.dps.kd.kfplc.com", "Origin": "https://dc.kfplc.com", "Referer": "https://dc.kfplc.com/", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36", "kits-app-version": "2.0.0", "kits-application-name": "DigitalColleague", "kits-device-id": `desktop_${Date.now()}`, "kits-device-type": "desktop", "kits-operating-company": "CF01", "kits-process-name": "Default", "kits-release-version": "CHG0168134", "kits-store-code": "1502", "kits-tenant-id": "CAFR", "sec-fetch-dest": "empty", "sec-fetch-mode": "cors", "sec-fetch-site": "same-site", });
    const fetchLayoutInfoForBay = (aisle, bay) => { return new Promise((resolve) => { const url = `${API_BASE_URL}/location-management/locations?areaType=A&aisle=${aisle}&bay=${bay}&locationType=LM&storageType=IM&suggestNextBin=true&numBinsToSuggest=1`; GM_xmlhttpRequest({ method: "GET", url, headers: getApiHeaders(), onload: (r) => { try { if (r.status === 200) { const d = JSON.parse(r.responseText); const l = d.find(loc => loc.segment && loc.segment.layoutModuleNumber); if (l && l.segment) { resolve(l.segment); } else { log('warn', `âš ï¸ No valid segment info for ${aisle}-${bay}.`, {d}); resolve(null); } } else { log('error', `Failed fetch layout info for ${aisle}-${bay}. Status: ${r.status}`, { r: (r.responseText || '').substring(0, 500) }); resolve(null); } } catch (e) { log('error', `Error parsing layout info JSON for ${aisle}-${bay}.`, { e, r: (r.responseText || '').substring(0, 500) }); resolve(null); } }, onerror: (e) => { log('error', `Network error fetching layout info for ${aisle}-${bay}:`, e); resolve(null); } }); }); };
    const fetchEansForLayout = (layoutInfo) => { return new Promise((resolve) => { if (!layoutInfo || !layoutInfo.layoutModuleNumber) { resolve([]); return; } const { layoutModuleNumber, version, segmentNumber } = layoutInfo; const url = `${API_BASE_URL}/location-management/layoutmodules/${layoutModuleNumber}-${version}/segments/${segmentNumber}`; GM_xmlhttpRequest({ method: "GET", url, headers: getApiHeaders(), onload: (r) => { try { if (r.status === 200) { const d = JSON.parse(r.responseText); const eans = [...new Set([...(d.products?.map(p => p.ean) || []), ...(d.storeProducts?.map(p => p.ean) || [])])]; log('info', `âœ… Layout trouvÃ©: ${layoutModuleNumber} / ${eans.length} EANs associÃ©s.`); resolve(eans); } else { log('error', `Failed to fetch EANs for ${layoutModuleNumber}. Status: ${r.status}`, { r: (r.responseText || '').substring(0, 500) }); resolve([]); } } catch (e) { log('error', `Error parsing EAN JSON for ${layoutModuleNumber}.`, { e, r: (r.responseText || '').substring(0, 500) }); resolve([]); } }, onerror: (e) => { log('error', `Network error fetching EANs for ${layoutModuleNumber}:`, e); resolve([]); } }); }); };
    const fetchProductDetails = (ean) => { return new Promise((resolve) => { const url = `${API_BASE_URL}/product/product-query/${ean}?hasGapi=true`; const payload = JSON.stringify({ "sapi": { "stockVisibility": true }, "productTask": {}, "locations": { "byProductNumber": true }, "expectedDeliveries": { "startDate": new Date().toISOString().split('T')[0], "endDate": new Date(new Date().setMonth(new Date().getMonth() + 6)).toISOString().split('T')[0] }, }); GM_xmlhttpRequest({ method: "POST", url, headers: getApiHeaders(), data: payload, onload: (r) => { try { if (r.status >= 200 && r.status < 300) { const d = JSON.parse(r.responseText); const locations = d.locations?.data || []; const mainLocationProduct = locations.flatMap(loc => BAYS_TO_CHECK.some(b => loc.aisle === b.aisle && loc.bay === b.bay) ? (loc.products || []) : []).find(p => p.ean === ean); const maximum = mainLocationProduct ? parseFloat(mainLocationProduct.maximum) : DEFAULT_MAX_CAPACITY; resolve({ ean, name: d.productTask?.data?.name || "Unknown Product", stock: d.sapi?.data?.sellingStore?.availableQuantity ?? 0, deliveries: d.expectedDeliveries?.data || [], locations, maximum }); } else { log('warn', `API request failed for EAN ${ean}. Status: ${r.status}`, { r: (r.responseText || '').substring(0, 500) }); resolve(null); } } catch (e) { log('error', `Error parsing JSON for EAN ${ean}:`, { e, r: (r.responseText || '').substring(0, 500) }); resolve(null); } }, onerror: (e) => { log('error', `Network error for EAN ${ean}:`, e); resolve(null); } }); }); };
    const analyzeData = (allProductData) => { const validProducts = allProductData.filter(p => p !== null); const overflowRisks = validProducts.filter(p => p.stock > p.maximum && Array.isArray(p.deliveries) && p.deliveries.length > 0).map(p => ({ ...p, potentialSurplus: (p.stock + p.deliveries[0].quantity) - p.maximum })); const topHighStockDeliveries = validProducts.filter(p => p.stock > 0 && Array.isArray(p.deliveries) && p.deliveries.length > 0).sort((a, b) => b.stock - a.stock).slice(0, 10); const misplacedProducts = validProducts.filter(p => p.stock > 0 && Array.isArray(p.locations) && p.locations.some(loc => loc.id.includes('999'))); const purchaseOrderAnalysis = {}; validProducts.forEach(product => { if (Array.isArray(product.deliveries)) { product.deliveries.forEach(delivery => { const isRisky = product.stock > product.maximum; if (Array.isArray(delivery.purchaseOrders) && delivery.purchaseOrders.length > 0) { delivery.purchaseOrders.forEach(poNumber => { if (!poNumber) return; if (!purchaseOrderAnalysis[poNumber]) { purchaseOrderAnalysis[poNumber] = { totalItems: 0, overflowItems: 0 }; } purchaseOrderAnalysis[poNumber].totalItems++; if (isRisky) { purchaseOrderAnalysis[poNumber].overflowItems++; } }); } else { const fallbackKey = i18n.noPoDelivery.replace('{date}', new Date(delivery.date).toLocaleDateString('fr-FR')); if (!purchaseOrderAnalysis[fallbackKey]) { purchaseOrderAnalysis[fallbackKey] = { totalItems: 0, overflowItems: 0 }; } purchaseOrderAnalysis[fallbackKey].totalItems++; if (isRisky) { purchaseOrderAnalysis[fallbackKey].overflowItems++; } } }); } }); return { totalProducts: validProducts.length, misplacedProducts, overflowRisks, topHighStockDeliveries, purchaseOrderAnalysis }; };
    const executeSearchForBarcodes = (ean) => { return new Promise((resolve) => { GM_xmlhttpRequest({ method: 'POST', url: `${FLASH_SERVER_URL}/pda/search/executeSearch`, data: `searchString=${encodeURIComponent(ean)}&ajax=1`, headers: { 'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8', 'X-Requested-With': 'XMLHttpRequest' }, onload: (response) => { if (response.status === 200) { const parser = new DOMParser(); const doc = parser.parseFromString(response.responseText, "text/html"); const barcodes = Array.from(doc.querySelectorAll('tr[id^="ESL_"]')).map(row => row.id.replace('ESL_', '')); resolve(barcodes); } else { resolve([]); } }, onerror: () => resolve([]) }); }); };
    const startFlashForBarcodes = (barcodes) => { if (barcodes.length === 0) return; const barcodeParams = barcodes.map(b => `barcodes=${encodeURIComponent(b)}`).join('&'); const url = `${FLASH_SERVER_URL}/pda/search/startFlash?${barcodeParams}&duration=1800&_=${Date.now()}`; GM_xmlhttpRequest({ method: 'GET', url, onload: (response) => { if (response.status === 200) { log('info', `[Auto-Flash] Successfully initiated flash for ${barcodes.length} labels.`); } else { log('error', `[Auto-Flash] Flash command failed with status ${response.status}.`); } }, onerror: () => log('error', `[Auto-Flash] Flash command network error.`) }); };
    const flashAnomalies = async (anomalies) => { if (!anomalies || anomalies.length === 0) { log('info', '[Auto-Flash] No anomalies to flash.'); return; } const anomalyEans = anomalies.map(p => p.ean).sort(); const lastFlashTimestamp = await GM.getValue('kfsFlashTimestamp', 0); const lastFlashedEans = await GM.getValue('kfsFlashedEans', []); const isSameList = JSON.stringify(anomalyEans) === JSON.stringify(lastFlashedEans); if (isSameList && (Date.now() - lastFlashTimestamp < FLASH_COOLDOWN_MS)) { log('info', '[Auto-Flash] Skipping flash, within cooldown period with same anomaly list.'); return; } log('warn', '[Auto-Flash] Anomaly list changed or cooldown expired. Initiating flash process...'); const searchPromises = anomalies.map(p => executeSearchForBarcodes(p.ean)); const allBarcodesNested = await Promise.all(searchPromises); const uniqueBarcodes = [...new Set(allBarcodesNested.flat())]; if (uniqueBarcodes.length > 0) { startFlashForBarcodes(uniqueBarcodes); await GM.setValue('kfsFlashTimestamp', Date.now()); await GM.setValue('kfsFlashedEans', anomalyEans); } else { log('warn', '[Auto-Flash] No electronic labels found for any of the anomalous products.'); } };

    // --- UI & RENDERING ---
    const addDashboardStyles = () => { GM_addStyle(`:root {--dash-font: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; --dash-bg-deep: #0d1b2a; --dash-bg-main: #1b263b; --dash-border: #415a77; --dash-text-primary: #e0e1dd; --dash-text-secondary: #778da9; --dash-accent: #3a86ff;} .kfs-dashboard-overlay, .kfs-dashboard-container, #kfs-floating-trigger {font-family: var(--dash-font);} #kfs-floating-trigger{position:fixed;bottom:25px;right:25px;z-index:9999;background-color:var(--dash-accent);color:#fff;border:none;border-radius:50%;width:60px;height:60px;font-size:28px;cursor:pointer;box-shadow:0 5px 15px rgba(0,0,0,.3);transition:transform .2s ease,background-color .2s ease;display:flex;justify-content:center;align-items:center} #kfs-floating-trigger:hover{transform:scale(1.1);background-color:#5c9cff} .kfs-dashboard-overlay{position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(0,0,0,.6);-webkit-backdrop-filter:blur(8px);backdrop-filter:blur(8px);z-index:10000;display:flex;justify-content:center;align-items:center;opacity:0;visibility:hidden;transition:opacity .3s,visibility .3s} .kfs-dashboard-overlay.visible{opacity:1;visibility:visible} .kfs-dashboard-container{width:95%;height:90%;background:var(--dash-bg-main);color:var(--dash-text-primary);border-radius:16px;border:1px solid var(--dash-border);box-shadow:0 10px 30px rgba(0,0,0,.2);display:flex;flex-direction:column;overflow:hidden;transform:scale(.95);transition:transform .3s} .kfs-dashboard-overlay.visible .kfs-dashboard-container{transform:scale(1)} .kfs-dashboard-header{padding:15px 25px;display:flex;justify-content:space-between;align-items:center;border-bottom:1px solid var(--dash-border);background:var(--dash-bg-deep);flex-shrink:0} .kfs-dashboard-header h1{margin:0;font-size:20px;color:var(--dash-text-primary);font-weight:500; flex-grow: 1;} .kfs-dashboard-header .kfs-status{color:var(--dash-text-secondary)} .kfs-reload-btn{background:none;border:none;color:var(--dash-text-secondary);font-size:20px;cursor:pointer;transition:transform .4s ease,color .2s;margin-left:15px;padding:5px;} .kfs-reload-btn:hover{color:var(--dash-accent);transform:rotate(180deg)} .kfs-dashboard-close{font-size:28px;font-weight:300;cursor:pointer;border:none;background:none;color:var(--dash-text-secondary);transition:transform .2s, color .2s; margin-left: 15px;} .kfs-dashboard-close:hover{transform:rotate(90deg);color:var(--dash-accent)} .kfs-dashboard-content{flex-grow:1;padding:25px;overflow-y:auto;display:grid;grid-template-columns:repeat(auto-fit,minmax(400px,1fr));gap:25px} .kfs-widget{background:var(--dash-bg-deep);border:1px solid var(--dash-border);border-radius:12px;padding:20px;display:flex;flex-direction:column} .kfs-widget-header{padding-bottom:15px;margin-bottom:15px;border-bottom:1px solid var(--dash-border);display:flex;align-items:center;gap:12px} .kfs-widget-header h2{margin:0;font-size:18px;font-weight:500;color:var(--dash-text-primary)} .kfs-widget-header .icon{font-size:20px;color:var(--dash-accent)} .kfs-widget-content{flex-grow:1;overflow-y:auto} .kfs-summary-grid{display:grid;grid-template-columns:1fr 1fr;gap:15px;height:100%} .kfs-summary-item{padding:15px;border-radius:8px;display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;background:var(--dash-bg-main)} .kfs-summary-item .count{font-size:42px;font-weight:700;line-height:1.1;display:block} .kfs-summary-item .label{font-size:14px;color:var(--dash-text-secondary);margin-top:5px} .kfs-widget table{width:100%;border-collapse:collapse;font-size:14px} .kfs-widget th,.kfs-widget td{padding:12px 10px;text-align:left;border-bottom:1px solid var(--dash-border); vertical-align: middle;} .kfs-widget th{font-weight:500;color:var(--dash-text-secondary);font-size:12px;text-transform:uppercase; white-space: nowrap;} .kfs-widget tr:last-child td{border-bottom:none} .kfs-pill{padding:4px 10px;border-radius:12px;font-weight:600;font-size:13px;text-align:center;min-width:40px;display:inline-block;background-color:var(--dash-border);color:var(--dash-text-primary)} .kfs-loader{text-align:center;padding:50px;font-size:18px;color:var(--dash-text-secondary)} .kfs-loader::before{content:'âš™ï¸';display:block;font-size:40px;margin-bottom:15px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}} .kfs-loader .kfs-error-details{font-size:14px;color:var(--dash-accent);margin-top:15px;font-family:monospace;} .kfs-widget-content::-webkit-scrollbar{width:8px} .kfs-widget-content::-webkit-scrollbar-track{background:transparent} .kfs-widget-content::-webkit-scrollbar-thumb{background-color:var(--dash-border);border-radius:10px} .kfs-widget-content::-webkit-scrollbar-thumb:hover{background-color:#555} .kfs-product-link {color: var(--dash-text-primary); text-decoration: none; transition: color 0.2s, text-decoration 0.2s;} .kfs-product-link:hover {color: var(--dash-accent); text-decoration: underline;}`); };
    const renderDashboard = (analysis) => { const contentEl = document.getElementById('kfs-dashboard-content'); contentEl.innerHTML = ''; const { totalProducts, misplacedProducts, overflowRisks, topHighStockDeliveries, purchaseOrderAnalysis } = analysis; const createProductLink = (product) => `<a href="https://dc.kfplc.com/product-query/${product.ean}" target="_blank" class="kfs-product-link">${product.name}</a>`; const createWidget = (icon, title, content) => `<div class="kfs-widget"><div class="kfs-widget-header"><span class="icon">${icon}</span><h2>${title}</h2></div><div class="kfs-widget-content">${content}</div></div>`; const summaryContent = `<div class="kfs-summary-grid"><div class="kfs-summary-item"><span class="count">${totalProducts}</span><span class="label">${i18n.productsAnalyzed}</span></div><div class="kfs-summary-item"><span class="count" style="color:#fcc419;">${misplacedProducts.length}</span><span class="label">${i18n.locationAnomalies}</span></div><div class="kfs-summary-item"><span class="count" style="color:#f03e3e;">${overflowRisks.length}</span><span class="label">${i18n.overflowRisks}</span></div><div class="kfs-summary-item"><span class="count" style="color:#3a86ff;">${Object.keys(purchaseOrderAnalysis).length}</span><span class="label">${i18n.upcomingPOs}</span></div></div>`; const summaryWidget = `<div class="kfs-widget" style="grid-column: 1 / -1; padding: 0; background: transparent; border: none;">${summaryContent}</div>`; const anomaliesContent = `<table><thead><tr><th>${i18n.productNameHeader}</th><th>${i18n.stockHeader}</th><th>${i18n.locationHeader}</th></tr></thead><tbody>${misplacedProducts.map(p => { const anomalyLocs = p.locations.filter(l => l.id.includes('999')).map(l => l.id).join('<br>'); return `<tr><td>${createProductLink(p)}</td><td style="text-align:center;"><span class="kfs-pill" style="background-color:#fcc41920;color:#fcc419;">${p.stock}</span></td><td>${anomalyLocs}</td></tr>`;}).join('') || `<tr><td colspan="3">${i18n.noAnomalies}</td></tr>`}</tbody></table>`; const overflowRisksContent = `<table><thead><tr><th>${i18n.productNameHeader}</th><th>${i18n.stockMaxHeader}</th><th>${i18n.potentialSurplusHeader}</th></tr></thead><tbody>${overflowRisks.map(p => `<tr><td>${createProductLink(p)}</td><td style="text-align:center;"><span class="kfs-pill" style="background-color:#f03e3e20;color:#f03e3e;">${p.stock}</span> / ${p.maximum}</td><td>+${p.potentialSurplus} (QtÃ©: ${p.deliveries[0].quantity})<br>le ${new Date(p.deliveries[0].date).toLocaleDateString('fr-FR')}</td></tr>`).join('') || `<tr><td colspan="3">${i18n.noOverflowRisks}</td></tr>`}</tbody></table>`; const poContent = `<table><thead><tr><th>${i18n.poNumberHeader}</th><th>${i18n.riskPercentHeader}</th><th>${i18n.detailsHeader}</th></tr></thead><tbody>${Object.entries(purchaseOrderAnalysis).map(([po, data]) => { const riskPercent = data.totalItems > 0 ? Math.round((data.overflowItems / data.totalItems) * 100) : 0; return `<tr><td>${po}</td><td style="text-align:center;"><span class="kfs-pill">${riskPercent}%</span></td><td>${i18n.riskDetails.replace('{overflow}', data.overflowItems).replace('{total}', data.totalItems)}</td></tr>`; }).join('') || `<tr><td colspan="3">${i18n.noPOs}</td></tr>`}</tbody></table>`; const highStockContent = `<table><thead><tr><th>${i18n.productNameHeader}</th><th>${i18n.stockMaxHeader}</th><th>${i18n.deliveryQtyHeader}</th></tr></thead><tbody>${topHighStockDeliveries.map(p => `<tr><td>${createProductLink(p)}</td><td style="text-align:center;"><span class="kfs-pill" style="background-color:#fcc41920;color:#fcc419;">${p.stock}</span> / ${p.maximum}</td><td style="text-align:center;">${p.deliveries.reduce((sum, d) => sum + d.quantity, 0)}</td></tr>`).join('') || `<tr><td colspan="3">${i18n.noHighStock}</td></tr>`}</tbody></table>`; contentEl.innerHTML = summaryWidget + createWidget('ðŸ”', i18n.anomaliesTitle, anomaliesContent) + createWidget('âš ï¸', i18n.overflowAnalysisTitle, overflowRisksContent) + createWidget('ðŸšš', i18n.poBreakdownTitle, poContent) + createWidget('ðŸ“ˆ', i18n.highStockTitle, highStockContent); document.getElementById('kfs-status').textContent = i18n.statusComplete.replace('{bays}', BAYS_TO_CHECK.map(b => `${b.aisle}-${b.bay}`).join(', ')); };
    const createDashboardUI = () => { if (document.getElementById('kfs-dashboard-overlay')) return; const overlay = document.createElement('div'); overlay.id = 'kfs-dashboard-overlay'; overlay.className = 'kfs-dashboard-overlay'; overlay.innerHTML = `<div id="kfs-dashboard-container" class="kfs-dashboard-container"><header class="kfs-dashboard-header"><h1 id="kfs-dashboard-title">${i18n.dashboardTitle}</h1><button id="kfs-force-reload" class="kfs-reload-btn" title="Forcer le rechargement">ðŸ”„</button><span id="kfs-status"></span><button id="kfs-dashboard-close" class="kfs-dashboard-close">Ã—</button></header><main id="kfs-dashboard-content" class="kfs-dashboard-content"></main></div>`; document.body.appendChild(overlay); document.getElementById('kfs-dashboard-close').addEventListener('click', () => overlay.classList.remove('visible')); document.getElementById('kfs-force-reload').addEventListener('click', () => fetchAndProcessData(true)); };
    const renderProgressState = (message, isError = false) => { const contentEl = document.getElementById('kfs-dashboard-content'); let errorDetails = isError ? `<div class="kfs-error-details">${i18n.errorCheckConsole}</div>` : ''; contentEl.innerHTML = `<div class="kfs-loader">${message}${errorDetails}</div>`; document.getElementById('kfs-status').textContent = message; };
    const createFloatingTriggerButton = () => { const triggerButton = document.createElement('button'); triggerButton.innerHTML = 'ðŸ“Š'; triggerButton.id = 'kfs-floating-trigger'; triggerButton.title = i18n.dashboardTitle; triggerButton.addEventListener('click', runAnalysis); document.body.appendChild(triggerButton); };

    // --- MAIN EXECUTION ---
    async function fetchAndProcessData(isForced = false) { if (isForced) { log('warn', 'Force reload triggered. Bypassing cache.'); renderProgressState(i18n.forcingReload); } try { renderProgressState(i18n.step1); const layoutInfoPromises = BAYS_TO_CHECK.map(bay => fetchLayoutInfoForBay(bay.aisle, bay.bay)); const validLayoutInfos = (await Promise.all(layoutInfoPromises)).filter(Boolean); if (validLayoutInfos.length === 0) { renderProgressState(i18n.errorLayout, true); return; } renderProgressState(i18n.step2.replace('{count}', validLayoutInfos.length)); const eanPromises = validLayoutInfos.map(fetchEansForLayout); const eanLists = await Promise.all(eanPromises); const uniqueEans = [...new Set(eanLists.flat())]; if (uniqueEans.length === 0) { renderProgressState(i18n.errorEan, true); return; } let checkedCount = 0; const productDetailPromises = uniqueEans.map(ean => fetchProductDetails(ean).then(result => { checkedCount++; renderProgressState(i18n.step3.replace('{checked}', checkedCount).replace('{total}', uniqueEans.length)); return result; })); const allProductData = (await Promise.all(productDetailPromises)).filter(Boolean); if (allProductData.length > 0) { log('info', `--- Inventaire complet des ${allProductData.length} produits trouvÃ©s ---`); const stockLogData = allProductData.map(p => ({ EAN: p.ean, Stock: p.stock, "Nom du Produit": p.name })); console.table(stockLogData); } renderProgressState(i18n.finalizing); const analysis = analyzeData(allProductData); await GM.setValue('kfsDashboardData', JSON.stringify(analysis)); await GM.setValue('kfsDashboardTimestamp', Date.now()); log('info', "New data has been fetched and saved to cache."); renderDashboard(analysis); flashAnomalies(analysis.misplacedProducts); } catch (error) { log("error", "A critical error occurred during the main analysis process:", error); renderProgressState(i18n.errorCritical.replace('{message}', error.message), true); } }
    const runAnalysis = async () => { const overlay = document.getElementById('kfs-dashboard-overlay'); overlay.classList.add('visible'); const lastTimestamp = await GM.getValue('kfsDashboardTimestamp', 0); const cachedData = await GM.getValue('kfsDashboardData', null); const dataAge = Date.now() - lastTimestamp; if (cachedData && dataAge < CACHE_DURATION_MS) { log('info', "Loading data from cache. Age: " + (dataAge / 1000 / 60).toFixed(1) + " minutes."); renderProgressState(i18n.loadingFromCache); setTimeout(() => { const analysis = JSON.parse(cachedData); renderDashboard(analysis); flashAnomalies(analysis.misplacedProducts); }, 500); } else { fetchAndProcessData(false); } };

    // --- SCRIPT INITIALIZATION ---
    log('info', "KFS Dashboard Script (v3.0) Loaded. Ready to use.");
    addDashboardStyles();
    createDashboardUI();
    createFloatingTriggerButton();

})();